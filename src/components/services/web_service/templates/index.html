<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evove Terminal</title>
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#7aa2f7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0d0e12;
            --term-bg: #1a1b26;
            --accent: #7aa2f7;
            --text-main: #c0caf5;
            --text-dim: #565f89;
            --success: #9ece6a;
            --warning: #e0af68;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background-color: var(--bg-color);
            color: var(--text-main);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 1rem;
        }

        /* Top area for live render (CLI Style) */
        #live-render {
            padding-bottom: 1rem;
            border-bottom: 1px dashed var(--text-dim);
            margin-bottom: 1rem;
            min-height: 4.5rem;
        }

        #buffer-view {
            color: var(--warning);
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 4px;
        }

        #points-view {
            color: #fff;
            font-family: 'Courier New', 'Courier', monospace;
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 6px;
            letter-spacing: 0.1em;
            text-shadow: none;
        }

        #process-view {
            color: var(--accent);
            font-size: 0.9rem;
            min-height: 1.1rem;                /* não colapsa quando vazio */
            transition: opacity 0.2s ease;
        }

        /* ── preview token styles ── */
        .preview-token {
            color: var(--text-main);
            font-weight: 700;
        }
        .preview-token .token-name {
            color: var(--warning);             /* nome da entidade: laranja */
        }
        .preview-token .token-label {
            color: var(--success);             /* label do tipo: verde */
        }
        .preview-arrow {
            color: var(--text-dim);
            margin: 0 6px;
            font-weight: 400;
        }
        .preview-cursor {
            color: var(--warning);
            animation: blink 1s step-end infinite;
        }
        .preview-incomplete {
            color: var(--text-dim);
            font-style: italic;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50%      { opacity: 0; }
        }

        /* History area */
        #terminal-output {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 4px;
            scrollbar-width: thin;
            scrollbar-color: var(--text-dim) transparent;
        }

        #terminal-output::-webkit-scrollbar {
            width: 4px;
        }

        #terminal-output::-webkit-scrollbar-thumb {
            background: var(--text-dim);
        }

        .line {
            animation: fadeIn 0.1s ease-out;
            white-space: pre-wrap;
            word-break: break-all;
            padding: 2px 0;
        }

        .line-right {
            animation: fadeIn 0.1s ease-out;
            white-space: pre-wrap;
            word-break: break-all;
            padding: 2px 0;
            margin-left: 10rem;
        }

        .system {
            color: var(--accent);
        }

        .success {
            color: var(--success);
        }

        .dim {
            color: var(--text-dim);
        }

        .container-esp {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            width: 100%;
            gap: 15px;
        }

        /* ─── Input bar ─── */
        .input-bar {
            display: flex;
            gap: 1px;
            background: var(--term-bg);
            border-top: 1px solid rgba(122, 162, 247, 0.2);
            margin: 0 -1rem -1rem -1rem;
        }

        /* ─── cada campo ─── */
        .input-area {
            flex: 1;
            display: flex;
            align-items: center;
            padding: 1rem;
            min-width: 0;
            position: relative;
            background: var(--term-bg);
            transition: background 0.4s ease, opacity 0.35s ease;
        }

        .input-area + .input-area {
            border-left: 1px solid rgba(122, 162, 247, 0.15);
        }

        /* ── INATIVO: escurece + apaga ── */
        .input-area:not(.active) {
            background: color-mix(in srgb, var(--term-bg) 88%, #000 12%);
            opacity: 0.45;
        }

        /* ── ATIVO: volta à base ── */
        .input-area.active {
            background: var(--term-bg);
            opacity: 1;
        }

        /* ── scan-line na borda inferior
           pseudo-elemento que desliza da esquerda para a direita ao ativar ── */
        .input-area::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            height: 2px;
            width: 100%;
            transform: scaleX(0);
            transform-origin: left center;
            transition: transform 0.45s cubic-bezier(0.22, 1, 0.36, 1),
                        background 0.3s ease,
                        box-shadow 0.3s ease;
        }

        .input-area.active::after {
            transform: scaleX(1);
        }

        /* cores da scan-line por campo */
        .input-area[data-field="text"]::after {
            background: var(--accent);
            box-shadow: 0 0 7px 2px var(--accent);
        }
        .input-area[data-field="dial"]::after {
            background: var(--success);
            box-shadow: 0 0 7px 2px var(--success);
        }

        /* ── prompt ── */
        .prompt {
            margin-right: 10px;
            font-weight: bold;
            flex-shrink: 0;
            user-select: none;
            color: var(--text-dim);
            transition: color 0.35s ease, text-shadow 0.35s ease;
        }

        .input-area[data-field="text"].active .prompt  { color: var(--accent);  text-shadow: 0 0 8px var(--accent); }
        .input-area[data-field="dial"].active .prompt   { color: var(--success); text-shadow: 0 0 8px var(--success); }

        /* ── input ── */
        .input-area input {
            flex: 1;
            background: transparent;
            border: none;
            color: #fff;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            outline: none;
            min-width: 0;
            transition: color 0.3s ease;
        }

        .input-area:not(.active) input       { color: var(--text-dim); }
        .input-area input::placeholder       { color: var(--text-dim); transition: color 0.3s ease; }
        .input-area.active input::placeholder { color: rgba(196,202,245,0.38); }

        /* ── label ── */
        .input-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .input-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 2px;
            padding-left: 2px;
            color: var(--text-dim);
            opacity: 0.55;
            transition: color 0.35s ease, opacity 0.35s ease, text-shadow 0.35s ease;
        }

        .input-area[data-field="text"].active .input-label { color: var(--accent);  opacity: 1; text-shadow: 0 0 6px var(--accent); }
        .input-area[data-field="dial"].active .input-label  { color: var(--success); opacity: 1; text-shadow: 0 0 6px var(--success); }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(3px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>

<body>
    <div id="live-render">
        <div id="points-view">0.0</div>
        <div id="buffer-view">_</div>
        <div id="process-view">Ready.</div>
    </div>

    <div id="terminal-output">
        <div class="container-esp">
            <div class="line dim">evove</div>
            <div class="line dim">by roko</div>
        </div>
        <div class="line dim">v0.1.0</div>
        <div class="line dim">Type numbers to interact.</div>
    </div>

    <div class="input-bar">
        <div class="input-area active" data-field="text">
            <span class="prompt">&gt;</span>
            <div class="input-wrapper">
                <span class="input-label">texting</span>
                <input type="text" id="text-input" placeholder="type a message…" inputmode="text" autocomplete="off">
            </div>
        </div>
        <div class="input-area" data-field="dial">
            <span class="prompt">&gt;</span>
            <div class="input-wrapper">
                <span class="input-label">dialing</span>
                <input type="text" id="dial-input" placeholder="dial a number…" inputmode="numeric" autocomplete="off">
            </div>
        </div>
    </div>

    <script>
        // ─── refs ───
        const output       = document.getElementById('terminal-output');
        const bufferView   = document.getElementById('buffer-view');
        const pointsView   = document.getElementById('points-view');
        const processView  = document.getElementById('process-view');
        const textInput    = document.getElementById('text-input');
        const dialInput    = document.getElementById('dial-input');
        const textArea     = document.querySelector('[data-field="text"]');
        const dialArea     = document.querySelector('[data-field="dial"]');

        // ─── estado ───
        let isPending      = false;
        let pendingType    = null;   // "text" | "numeric" | "confirm" | null
        let lastGuidePrompt = null;

        // ────────────────────────────────────────────
        // FOCO CENTRALIZADO
        // Regras de prioridade:
        //   1. pending do servidor → foca conforme o tipo pedido
        //   2. sem pending          → foca no dial (modo padrão)
        // Chamado após cada updateStatus() e após cada submit bem-sucedido.
        // ────────────────────────────────────────────
        function focusCorrectInput(pending) {
            let target; // "text" | "dial"

            if (pending) {
                // servidor pediu input — decide pelo tipo
                target = (pending.type === 'numeric') ? 'dial' : 'text';

                // atualiza placeholder do campo que vai receber o foco
                const prompt = (pending.prompt || '').toLowerCase();
                const genericPlaceholder = prompt.includes('label')
                    ? 'label'
                    : (prompt.includes('type') ? 'type' : 'type');

                const el = (target === 'text') ? textInput : dialInput;
                el.placeholder = genericPlaceholder;
            } else {
                // modo livre → dial é o padrão
                target = 'dial';
                textInput.placeholder  = 'type a message…';
                dialInput.placeholder  = 'dial a number…';
            }

            // aplica classe .active e foco
            textArea.classList.toggle('active', target === 'text');
            dialArea.classList.toggle('active', target === 'dial');

            const focused = (target === 'text') ? textInput : dialInput;
            focused.focus();
        }

        // ─── click manual em qualquer input → marca como ativo ───
        [textInput, dialInput].forEach(input => {
            input.addEventListener('focus', () => {
                const isText = (input === textInput);
                textArea.classList.toggle('active',  isText);
                dialArea.classList.toggle('active', !isText);
            });
        });

        // click fora dos inputs → volta ao padrão
        document.addEventListener('click', (e) => {
            if (!e.target.closest('input')) focusCorrectInput(null);
        });

        // ─── utilitários ───
        function addLine(text, type = '') {
            const div = document.createElement('div');
            div.className = `line ${type}`;
            div.innerText = text;
            output.appendChild(div);
            output.scrollTop = output.scrollHeight;
            if (output.children.length > 50) output.removeChild(output.firstChild);
        }

        function resetAfterSubmit(label) {
            textInput.value   = '';
            dialInput.value   = '';
            bufferView.innerText = '_';
            // mostra o label de status com a cor do accent
            processView.innerHTML = `<span style="color:var(--accent)">${label}</span>`;
            // após submit, busca novo estado do servidor → vai reajustar foco
            updateStatus();
        }

        async function updateStatus() {
            try {
                const res  = await fetch('/api/status');
                if (!res.ok) return;
                const data = await res.json();

                // atualiza pontos totais
                if (data.user && typeof data.user.total_points === 'number') {
                    pointsView.innerText = data.user.total_points;
                }

                // mensagens do servidor
                if (data.messages && data.messages.length > 0)
                    data.messages.forEach(msg => addLine(` ${msg}`, 'system'));

                // guia de input: imprime só quando mudar
                if (data.pending && data.pending.prompt) {
                    if (data.pending.prompt !== lastGuidePrompt) {
                        addLine(` ${data.pending.prompt}`, 'system');
                        lastGuidePrompt = data.pending.prompt;
                    }
                } else {
                    lastGuidePrompt = null;
                }

                // atualiza estado de pending
                isPending   = !!data.pending;
                pendingType = data.pending ? data.pending.type : null;

                // ← ponto central: reajusta foco
                focusCorrectInput(data.pending);

            } catch (e) { /* sem servidor */ }
        }

        function mirrorBuffer(value) {
            bufferView.innerText = value ? value + '_' : '_';
        }


        async function fetchPreview(buffer) {
            if (!buffer) {
                processView.innerHTML = '<span style="color:var(--accent)">Ready.</span>';
                return;
            }

            try {
                const res = await fetch(`/api/preview?buffer=${encodeURIComponent(buffer)}`);
                if (!res.ok) throw new Error('no server');
                const data = await res.json();
                renderPreview(data.preview, data.remaining, data.complete);
            } catch (e) {
                // fallback offline: mostra apenas o buffer + cursor
                renderPreview(buffer, 1, false);
            }
        }

        /**
         * Recebe a string "Label (Name) -> Label2 -> _"
         * e monta HTML com cores por parte.
         */
        function renderPreview(raw, remaining, complete) {
            if (!raw) {
                processView.innerHTML = '<span style="color:var(--accent)">Ready.</span>';
                return;
            }

            // split por " -> " para ter cada segmento
            const parts = raw.split(' -> ');
            let html = '';

            parts.forEach((part, i) => {
                if (i > 0) {
                    html += '<span class="preview-arrow">→</span>';
                }

                const trimmed = part.trim();

                if (trimmed === '_') {
                    // cursor piscante no final
                    html += '<span class="preview-cursor">_</span>';

                } else {
                    // tenta extrair "Label (Name)"
                    const match = trimmed.match(/^(.+?)\s*\((.+)\)$/);
                    if (match) {
                        const label = match[1].trim();
                        const name  = match[2].trim();
                        html += `<span class="preview-token">`
                              + `<span class="token-label">${label}</span>`
                              + ` <span class="token-name">(${name})</span>`
                              + `</span>`;
                    } else {
                        // sem parênteses → é um label simples ou payload bruto
                        html += `<span class="preview-token">`
                              + `<span class="token-label">${trimmed}</span>`
                              + `</span>`;
                    }
                }
            });

            // se completo, adiciona um ✔ discreto
            if (complete) {
                html += ' <span style="color:var(--success);font-size:0.75rem">✓</span>';
            }

            processView.innerHTML = html;
        }

        // ═══════════════════════════════════════════
        // INPUT DE TEXTO  (submit com Enter)
        // ═══════════════════════════════════════════
        textInput.addEventListener('input', (e) => {
            mirrorBuffer(e.target.value);
        });

        textInput.addEventListener('keydown', async (e) => {
            if (e.key !== 'Enter') return;
            const buffer = textInput.value.trim();
            if (!buffer) return;

            try {
                const res  = await fetch('/api/command', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ buffer })
                });
                const data = await res.json();
                if (data.completed) {
                    addLine(`> ${buffer}`, 'dim');
                    resetAfterSubmit('Sent.');
                }
            } catch (e) {
                addLine(`> ${buffer}`, 'dim');
                resetAfterSubmit('Sent (offline).');
            }
        });

        // ═══════════════════════════════════════════
        // INPUT NUMÉRICO (dial)
        //   • se isPending  → sem auto-submit, espera Enter
        //   • se livre      → auto-submit a cada dígito (comportamento original)
        // ═══════════════════════════════════════════
        dialInput.addEventListener('input', async (e) => {
            const buffer = dialInput.value;
            mirrorBuffer(buffer);

            // ── preview live sempre atualiza ──
            fetchPreview(buffer);

            if (!buffer) return;

            // quando há pending numérico, o usuário digita e pressiona Enter
            if (isPending) return;

            // auto-submit livre
            try {
                const res  = await fetch('/api/command', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ buffer })
                });
                const data = await res.json();

                if (data.completed) {
                    addLine(`$ ${buffer}`, 'dim');
                    resetAfterSubmit('Command executed.');
                }
                // se não completou, fetchPreview já mostrou o estado correto
            } catch (e) {
                addLine(`$ ${buffer}`, 'dim');
                resetAfterSubmit('Dialed (offline).');
            }
        });

        // Enter no dial → necessário quando isPending (confirma resposta)
        dialInput.addEventListener('keydown', async (e) => {
            if (e.key !== 'Enter') return;
            if (!isPending) return;           // sem pending, auto-submit já resolveu

            const buffer = dialInput.value.trim();
            if (!buffer) return;

            try {
                const res  = await fetch('/api/command', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ buffer })
                });
                const data = await res.json();
                if (data.completed) {
                    addLine(`? ${buffer}`, 'dim');
                    resetAfterSubmit('Confirmed.');
                }
            } catch (e) {
                addLine(`? ${buffer}`, 'dim');
                resetAfterSubmit('Confirmed (offline).');
            }
        });

        // ─── init ───
        setInterval(updateStatus, 3000);
        updateStatus();                          // primeira chamada → define foco inicial

        // Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(() => console.log('SW Registered'))
                    .catch(err => console.log('SW Failed', err));
            });
        }
    </script>
</body>

</html>
