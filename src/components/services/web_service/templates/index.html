<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Evove Phone</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Zalando+Sans+Expanded:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet">
    <script src="{{ url_for('static', filename='screen_ui.js') }}"></script>
    <style>
        :root {
            --bg: #000;
            --fg: #fff;
            --dim: #666;
            --green: #0f0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: #000;
            color: var(--fg);
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            pointer-events: none;
            background: radial-gradient(circle at 50% 85%, rgba(255, 255, 255, 0.08), transparent 45%);
            mix-blend-mode: screen;
            opacity: 0.6;
            z-index: 0;
        }

        #system-input {
            position: absolute;
            opacity: 0;
            width: 1px;
            height: 1px;
            border: 0;
            padding: 0;
            margin: 0;
        }

        /* DISPLAY */
        #display-row {
            flex: 0 0 45vh;
            background: #000;
            padding: 1.6rem 1.2rem;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-content: space-between;
            gap: 16px;
            min-height: 0;
            user-select: text;
            -webkit-user-select: text;
            position: relative;
            z-index: 1;
        }

        #phone-display {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: center;
            justify-content: center;
        }

        #display-points {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--fg);
            letter-spacing: 0.1em;
            text-align: center;
            opacity: 0.5;
        }

        #display-number {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--fg);
            text-align: center;
            letter-spacing: 0.08em;
            min-height: 3rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #display-number .ghost {
            color: var(--dim);
            opacity: 0.6;
        }

        #display-number.empty {
            color: var(--dim);
            font-size: 1.8rem;
        }

        #display-label {
            font-size: 0.8rem;
            color: var(--dim);
            text-align: right;
            min-height: 1rem;
        }

        #display-messages-panel {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            padding: 0.75rem;
            background: #000;
            min-height: 0;
            overflow: hidden;
        }

        #topbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.55rem;
            letter-spacing: 0.16em;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        #topbar .top-left {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        #topbar .brand {
            font-size: 0.55rem;
            letter-spacing: 0.22em;
            color: rgba(255, 255, 255, 0.45);
        }

        #topbar.hidden {
            transform: translateY(-120%);
            opacity: 0;
        }

        #display-messages {
            position: relative;
            flex: 1;
            font-size: 0.75rem;
            color: var(--fg);
            opacity: 0.85;
            line-height: 1.35;
            white-space: pre-wrap;
            text-align: left;
            overflow-y: auto;
            padding-right: 4px;
            min-height: 0;
        }

        #display-messages.screen-single,
        #display-messages.screen-list,
        #display-messages.screen-seq {
            font-family: "Zalando Sans Expanded", sans-serif;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            white-space: normal;
            opacity: 1;
        }

        #display-messages.screen-single {
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: clamp(1.1rem, 3.4vw, 2.2rem);
            line-height: 1.2;
            padding: 0 0.25rem;
        }

        #display-messages.screen-single .screen-message {
            width: 100%;
        }

        #display-messages.screen-seq {
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: clamp(1.05rem, 3.1vw, 2rem);
            line-height: 1.2;
            padding: 0 0.25rem;
        }

        #display-messages.screen-seq .screen-message {
            width: 100%;
        }

        #display-messages.screen-list {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            font-size: clamp(0.75rem, 2.1vw, 1.2rem);
            overflow: hidden;
        }

        .screen-title {
            font-size: 0.7rem;
            color: var(--dim);
            letter-spacing: 0.16em;
        }

        .screen-item {
            padding: 0.35rem 0.45rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: #000;
        }

        #display-messages.menu {
            white-space: normal;
        }

        #display-messages-panel #display-points {
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--fg);
            letter-spacing: 0.1em;
            text-align: left;
            opacity: 0.5;
        }

        #display-messages-panel #phone-display {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: center;
            justify-content: center;
        }

        #display-number {
            opacity: 0;
            transform: translateY(16px);
            transition: transform 0.25s ease, opacity 0.25s ease;
        }

        #display-number.visible {
            opacity: 1;
            transform: translateY(0);
        }

        #display-number .float-char {
            display: inline-block;
            animation: floatChar 2.4s ease-in-out infinite;
            animation-delay: var(--float-delay, 0s);
        }

        @keyframes floatChar {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }

        .menu-item {
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 0.6rem 0.8rem;
            margin-bottom: 0.5rem;
            background: #000;
            color: var(--fg);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-size: 0.7rem;
        }

        .menu-item.selected {
            background: #000;
            border-color: var(--green);
            color: var(--green);
        }

        #display-messages.menu {
            white-space: normal;
        }

        .menu-item {
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 0.6rem 0.8rem;
            margin-bottom: 0.5rem;
            background: #000;
            color: var(--fg);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-size: 0.7rem;
        }

        .menu-item.selected {
            background: #000;
            border-color: var(--green);
            color: var(--green);
        }

        #display-messages::-webkit-scrollbar {
            width: 6px;
        }

        #display-messages::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.18);
            border-radius: 6px;
        }

        /* KEYPAD - botões fixos centralizados */
        #phone-keypad {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg);
            padding: 1rem;
            user-select: none;
            -webkit-user-select: none;
            opacity: 1;
            pointer-events: auto;
            position: relative;
            z-index: 1;
        }

        #phone-keypad::before {
            content: '';
            position: absolute;
            inset: 10% 8% auto 8%;
            height: 70%;
            background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.12), transparent 60%);
            filter: blur(18px);
            opacity: 0.35;
            pointer-events: none;
        }

        #phone-keypad.mode-classic .key {
            border-color: var(--fg);
            color: var(--fg);
        }

        #phone-keypad.mode-nav .key {
            border-color: var(--fg);
            color: var(--fg);
        }

        #phone-keypad.mode-nav .key-number {
            color: var(--fg);
        }

        #phone-keypad.mode-nav .key.nav-active {
            border-color: var(--fg);
            color: var(--fg);
        }

        #phone-keypad.mode-nav .key.nav-active .key-number {
            color: var(--fg);
        }

        .fountain-wrap {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            background-image: url("https://img1.picmix.com/output/stamp/normal/1/9/0/0/2480091_90ce2.gif");
            background-size: 140% 140%;
            background-position: center;
            background-repeat: no-repeat;
            border-radius: 10px;
            overflow: hidden;
        }

        .fountain-count {
            position: absolute;
            left: 50%;
            top: 50%;
            font-size: 2.4rem;
            letter-spacing: 0.16em;
            color: var(--fg);
            transform: translate(-50%, -50%);
            animation: floaty 2.6s ease-in-out infinite;
            text-shadow: 0 2px 6px rgba(0,0,0,0.6);
            z-index: 1;
        }

        .fountain-count.pop {
            animation: pop 0.18s ease;
        }

        .fountain-count.throw {
            animation: throw 0.8s ease;
        }

        .fountain-wrap::before {
            content: "";
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.35);
            z-index: 0;
        }

        @keyframes floaty {
            0%, 100% { transform: translate(-50%, -50%) translateY(0px); }
            50% { transform: translate(-50%, -50%) translateY(-6px); }
        }

        @keyframes pop {
            0% { transform: translate(-50%, -50%) scale(1); }
            60% { transform: translate(-50%, -50%) scale(1.18); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes throw {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -70%) scale(0.7); opacity: 0.9; }
            100% { transform: translate(-50%, -40%) scale(0.4); opacity: 0.6; }
        }

        #phone-keypad.mode-classic .key {
            border-color: var(--fg);
            color: var(--fg);
        }

        #phone-keypad.mode-nav .key {
            border-color: #333;
            color: #333;
        }

        #phone-keypad.mode-nav .key-number {
            color: #333;
        }

        #phone-keypad.mode-nav .key.nav-active {
            border-color: var(--green);
            color: var(--green);
        }

        #phone-keypad.mode-nav .key.nav-active .key-number {
            color: var(--green);
        }

        .keypad-grid {
            display: grid;
            --key-size: min(21vw, 92px);
            --gap-size: min(3.2vw, 13px);
            grid-template-columns: repeat(3, var(--key-size));
            grid-template-rows: repeat(4, var(--key-size));
            gap: var(--gap-size);
        }

        .keypad-qwerty {
            display: none;
            flex-direction: column;
            --q-key-size: min(9.2vw, 40px);
            --q-gap-size: min(2.0vw, 8px);
            gap: var(--q-gap-size);
            opacity: 0;
            pointer-events: none;
        }

        .q-row {
            display: flex;
            gap: var(--q-gap-size);
            justify-content: center;
        }

        .key {
            background: transparent;
            border: 1px solid var(--fg);
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            cursor: pointer;
            transition: all 0.15s ease;
            user-select: none;
            -webkit-user-select: none;
            width: var(--key-size);
            height: var(--key-size);
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.08);
        }

        .key.letter {
            width: var(--q-key-size);
            height: var(--q-key-size);
            border-radius: 12px;
        }

        .key:active {
            transform: scale(0.92);
            background: var(--fg);
            box-shadow: 0 0 18px rgba(255, 255, 255, 0.5);
        }

        .key:active .key-number,
        .key:active .key-letters,
        .key:active .key-icon {
            color: var(--bg);
        }

        .key-number {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--fg);
            line-height: 1;
            transition: color 0.15s ease;
        }

        .key-letters {
            font-size: 0.6rem;
            color: var(--dim);
            text-transform: lowercase;
            letter-spacing: 0.1em;
            margin-top: 2px;
            transition: color 0.15s ease;
        }

        .key-icon {
            font-size: 1.6rem;
            color: var(--fg);
            font-weight: 700;
            transition: color 0.15s ease;
        }

        .key-icon.mode {
            color: var(--green);
        }

        .key.confirm {
            border-color: var(--fg);
            color: var(--fg);
        }

        .key.confirm .key-number {
            color: var(--fg);
        }

        .key.confirm:active {
            background: var(--fg);
            border-color: var(--fg);
        }

        .key.confirm:active .key-number {
            color: var(--bg);
        }

        #phone-keypad.text-input-active .key-letters {
            color: var(--green);
            opacity: 1;
        }

        #phone-keypad.text-input-active .key-number {
            opacity: 0.7;
        }

        /* QWERTY stays hidden; numeric keypad always visible */

        /* ACTION BAR */
        #action-bar {
            flex: 0 0 auto;
            display: flex;
            justify-content: center;
            padding: 1rem 1.5rem;
            padding-bottom: calc(1rem + env(safe-area-inset-bottom, 0px));
            background: var(--bg);
        }

        .action-btn {
            padding: 1rem 3rem;
            border: 2px solid var(--fg);
            border-radius: 2rem;
            background: transparent;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            font-weight: 700;
            color: var(--fg);
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .action-btn:active {
            transform: scale(0.95);
            background: var(--fg);
            color: var(--bg);
        }

        /* TOAST */
        #toast {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: var(--fg);
            color: var(--bg);
            padding: 1rem 2rem;
            border-radius: 1rem;
            font-size: 1rem;
            font-weight: 700;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        #toast.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        /* LOADSCREEN */
        #loadscreen {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 16px;
            background: #000;
            color: #f5f5f5;
            z-index: 2000;
            text-align: center;
            padding: 24px;
        }
        #loadscreen.show { display: flex; }
        #loadscreen .progress {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.2);
        }
        #loadscreen .progress-fill {
            height: 100%;
            width: 0%;
            background: #ffffff;
            transition: width 0.35s ease;
        }
        #loadscreen .status {
            position: absolute;
            top: 12px;
            left: 12px;
            right: 12px;
            text-align: left;
            font-size: 12px;
            color: rgba(255,255,255,0.85);
            text-transform: uppercase;
            letter-spacing: 0.06em;
        }

        /* LOCKSCREEN */
        #lockscreen {
            position: absolute;
            inset: 0;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            color: var(--fg);
            text-align: center;
            transition: transform 0.45s ease, opacity 0.45s ease;
            transform: translateY(0);
            opacity: 1;
            user-select: none;
        }

        #lockscreen.hidden {
            display: none;
        }

        #lockscreen.unlocking {
            transform: translateY(100%);
            opacity: 0;
            pointer-events: none;
        }

        #lockscreen.dragging {
            transition: none;
        }

        .lockscreen-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 12px;
        }

        .lock-time {
            font-family: "Zalando Sans Expanded", sans-serif;
            font-size: clamp(2.4rem, 8vw, 4.2rem);
            letter-spacing: 0.12em;
            text-transform: uppercase;
        }

        .lock-date {
            font-size: clamp(0.9rem, 2.8vw, 1.2rem);
            color: rgba(255, 255, 255, 0.78);
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .key.pressed {
            animation: pulse 0.3s ease;
        }

        #phone-keypad.locked .key {
            animation: keyBlink 4s ease-in-out infinite;
        }

        @keyframes keyBlink {
            0%, 100% { background: transparent; color: var(--fg); }
            50% { background: #fff; color: #000; }
        }
    </style>
</head>
<body>
    <div id="loadscreen">
        <div class="progress"><div class="progress-fill"></div></div>
        <div class="status" id="loadscreen-status"></div>
    </div>
    <!-- DISPLAY -->
    <div id="display-row">
        <div id="display-messages-panel">
            <div id="topbar">
                <div class="top-left">
                    <div id="display-points">0</div>
                    <div class="brand">EVOVE</div>
                </div>
                <span id="conn-status">CONNECTING</span>
            </div>
            <div id="display-messages">
                <div id="lockscreen">
                    <div class="lockscreen-content">
                        <div class="lock-time" id="lock-time">00:00</div>
                        <div class="lock-date" id="lock-date">Monday, February 10, 2026</div>
                    </div>
                </div>
            </div>
            <div id="phone-display">
                <div id="display-number"></div>
            </div>
            <div id="display-label">Ready.</div>
        </div>
    </div>

    <!-- KEYPAD -->
    <div id="phone-keypad">
        <div class="keypad-grid">
            <!-- Row 1 -->
            <button class="key" data-num="1">
                <span class="key-number">1</span>
                <span class="key-letters"></span>
            </button>
            <button class="key" data-num="2">
                <span class="key-number">2</span>
                <span class="key-letters">ABC</span>
            </button>
            <button class="key" data-num="3">
                <span class="key-number">3</span>
                <span class="key-letters">DEF</span>
            </button>

            <!-- Row 2 -->
            <button class="key" data-num="4">
                <span class="key-number">4</span>
                <span class="key-letters">GHI</span>
            </button>
            <button class="key" data-num="5">
                <span class="key-number">5</span>
                <span class="key-letters">JKL</span>
            </button>
            <button class="key" data-num="6">
                <span class="key-number">6</span>
                <span class="key-letters">MNO</span>
            </button>

            <!-- Row 3 -->
            <button class="key" data-num="7">
                <span class="key-number">7</span>
                <span class="key-letters">PQRS</span>
            </button>
            <button class="key" data-num="8">
                <span class="key-number">8</span>
                <span class="key-letters">TUV</span>
            </button>
            <button class="key" data-num="9">
                <span class="key-number">9</span>
                <span class="key-letters">WXYZ</span>
            </button>

            <!-- Row 4 - classic layout -->
            <button class="key" data-delete="1">
                <span class="key-number">-</span>
                <span class="key-letters"></span>
            </button>
            <button class="key" data-num="0">
                <span class="key-number">0</span>
                <span class="key-letters">+</span>
            </button>
            <button class="key confirm" data-confirm="1">
                <span class="key-number">●</span>
                <span class="key-letters"></span>
            </button>
        </div>
        <div class="keypad-qwerty" aria-label="QWERTY keyboard">
            <div class="q-row">
                <button class="key letter" data-char="Q"><span class="key-number">Q</span></button>
                <button class="key letter" data-char="W"><span class="key-number">W</span></button>
                <button class="key letter" data-char="E"><span class="key-number">E</span></button>
                <button class="key letter" data-char="R"><span class="key-number">R</span></button>
                <button class="key letter" data-char="T"><span class="key-number">T</span></button>
                <button class="key letter" data-char="Y"><span class="key-number">Y</span></button>
                <button class="key letter" data-char="U"><span class="key-number">U</span></button>
                <button class="key letter" data-char="I"><span class="key-number">I</span></button>
                <button class="key letter" data-char="O"><span class="key-number">O</span></button>
                <button class="key letter" data-char="P"><span class="key-number">P</span></button>
            </div>
            <div class="q-row">
                <button class="key letter" data-char="A"><span class="key-number">A</span></button>
                <button class="key letter" data-char="S"><span class="key-number">S</span></button>
                <button class="key letter" data-char="D"><span class="key-number">D</span></button>
                <button class="key letter" data-char="F"><span class="key-number">F</span></button>
                <button class="key letter" data-char="G"><span class="key-number">G</span></button>
                <button class="key letter" data-char="H"><span class="key-number">H</span></button>
                <button class="key letter" data-char="J"><span class="key-number">J</span></button>
                <button class="key letter" data-char="K"><span class="key-number">K</span></button>
                <button class="key letter" data-char="L"><span class="key-number">L</span></button>
            </div>
            <div class="q-row">
                <button class="key letter" data-char="Z"><span class="key-number">Z</span></button>
                <button class="key letter" data-char="X"><span class="key-number">X</span></button>
                <button class="key letter" data-char="C"><span class="key-number">C</span></button>
                <button class="key letter" data-char="V"><span class="key-number">V</span></button>
                <button class="key letter" data-char="B"><span class="key-number">B</span></button>
                <button class="key letter" data-char="N"><span class="key-number">N</span></button>
                <button class="key letter" data-char="M"><span class="key-number">M</span></button>
                <button class="key confirm" data-confirm="1"><span class="key-number">OK</span></button>
            </div>
        </div>
    </div>

    <!-- TOAST -->
    <div id="toast"></div>

    <script>
        // REFS
        const displayPoints = document.getElementById('display-points');
        const displayNumber = document.getElementById('display-number');
        const displayLabel  = document.getElementById('display-label');
        const displayMessages = document.getElementById('display-messages');
        const toast         = document.getElementById('toast');
        const topbar        = document.getElementById('topbar');
        const connStatus    = document.getElementById('conn-status');
        const lockscreen    = document.getElementById('lockscreen');
        const lockTime      = document.getElementById('lock-time');
        const lockDate      = document.getElementById('lock-date');
        const progressFill  = document.querySelector('#loadscreen .progress-fill');
        const loadscreen    = document.getElementById('loadscreen');
        const loadscreenStatus = document.getElementById('loadscreen-status');
        const keys          = document.querySelectorAll('.key');
        const keypad        = document.getElementById('phone-keypad');
        const displayRow    = document.getElementById('display-row');

        // STATE
        let buffer = '';
        let inputMode = 'dial';
        let pendingPrompt = '';
        let executing = false;
        let pendingType = '';
        let lastTapKey = null;
        let lastTapIndex = 0;
        let lastTapTime = 0;
        const multiTapTimeout = 800;
        const textMap = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        };
        let logSuggestions = [];
        let activeSuggestion = '';
        let activeSuggestionDisplay = '';
        let baseSuggestion = '';
        let suggestionActive = false;
        let uiMode = 'classic';
        let menuStack = [];
        let menuSelection = 0;
        let settingsData = null;
        let packagesData = null;
        let subScreen = 'list';
        let fountainValue = 0;
        let lastFountainValue = 0;
        let currentScore = 0;
        let holdTimer = null;
        let holdDir = 0;
        let holdStart = 0;
        let holdDelayTimer = null;
        let holdActive = false;
        let holdUsed = false;
        const screenUI = new ScreenUI(displayMessages);
        const STATUS_TIMEOUT_MS = 6000;
        const MIN_LOADSCREEN_MS = 1000;
        let statusInFlight = false;
        let statusTimeoutTimer = null;
        let loadscreenShownAt = 0;
        let loadProgress = 0;
        let bootTimer = null;
        let startupSoundPlayed = false;
        let startupUnlockBound = false;
        let startupSoundRequested = false;
        let lockActive = true;
        let lockDragStartY = 0;
        let lockDragDelta = 0;
        let lockDragging = false;
        let lastServerRender = null;

        function setLoadMessage(msg) {
            if (loadscreenStatus) loadscreenStatus.textContent = msg || '';
        }

        function setLoadProgress(pct) {
            loadProgress = Math.max(loadProgress, Math.min(100, pct));
            if (progressFill) progressFill.style.width = `${loadProgress}%`;
        }

        function showLoadscreen() {
            loadscreen.classList.add('show');
            loadscreenShownAt = Date.now();
            if (progressFill) progressFill.style.width = `${loadProgress}%`;
        }

        function hideLoadscreen() {
            const elapsed = Date.now() - loadscreenShownAt;
            const remaining = Math.max(0, MIN_LOADSCREEN_MS - elapsed);
            setTimeout(() => {
                loadscreen.classList.remove('show');
                if (progressFill) {
                    progressFill.style.width = '0%';
                }
                loadProgress = 0;
                if (!startupSoundRequested) {
                    startupSoundRequested = true;
                    playStartupSound();
                }
            }, remaining);
        }

        function setConnectionStatus(text) {
            if (connStatus) connStatus.textContent = text || '';
        }

        async function playStartupSound() {
            if (startupSoundPlayed) return;
            const addUnlockListeners = () => {
                if (startupUnlockBound) return;
                startupUnlockBound = true;
                const resume = () => {
                    if (startupSoundPlayed) return;
                    attemptPlay(true);
                    document.removeEventListener('pointerdown', resume);
                    document.removeEventListener('keydown', resume);
                    document.removeEventListener('touchstart', resume);
                    startupUnlockBound = false;
                };
                document.addEventListener('pointerdown', resume, { once: true });
                document.addEventListener('keydown', resume, { once: true });
                document.addEventListener('touchstart', resume, { once: true });
            };

            const attemptPlay = async (fromGesture) => {
                try {
                    if (audioCtx && audioCtx.state === 'suspended') {
                        await audioCtx.resume();
                    }
                    if (!audioCtx) {
                        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    const res = await fetch('/assets/audio/startup.wav');
                    if (!res.ok) throw new Error('audio');
                    const arrayBuf = await res.arrayBuffer();
                    const buffer = await audioCtx.decodeAudioData(arrayBuf);
                    const source = audioCtx.createBufferSource();
                    source.buffer = buffer;
                    source.connect(audioCtx.destination);
                    source.start(0);
                    startupSoundPlayed = true;
                    if (fromGesture) {
                        console.log('✓ Startup sound played after user gesture');
                    } else {
                        console.log('✓ Startup sound played');
                    }
                } catch (e) {
                    if (!fromGesture) {
                        console.log('⚠ Autoplay blocked — esperando interação');
                        addUnlockListeners();
                    }
                }
            };

            attemptPlay(false);
        }

        function updateLockTime() {
            const now = new Date();
            if (lockTime) {
                lockTime.textContent = now.toLocaleTimeString([], {
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }
            if (lockDate) {
                lockDate.textContent = now.toLocaleDateString([], {
                    weekday: 'long',
                    month: 'long',
                    day: 'numeric',
                    year: 'numeric'
                });
            }
        }

        function resetLockscreenPosition() {
            if (!lockscreen) return;
            lockscreen.classList.remove('dragging');
            lockscreen.style.transform = '';
            lockDragDelta = 0;
        }

        function unlockLockscreen() {
            if (!lockscreen || !lockActive) return;
            lockActive = false;
            playUnlockJingle();
            lockscreen.classList.remove('dragging');
            lockscreen.classList.add('unlocking');
            lockscreen.addEventListener('transitionend', () => {
                lockscreen.classList.add('hidden');
            }, { once: true });
            if (keypad) {
                keypad.classList.remove('locked');
            }
        }

        function bindLockscreenGestures() {
            if (!lockscreen) return;
            const unlockIfActive = () => {
                if (lockActive) {
                    unlockLockscreen();
                }
            };
            document.addEventListener('pointerdown', unlockIfActive, { capture: true });
            document.addEventListener('keydown', unlockIfActive, { capture: true });
            lockscreen.addEventListener('pointerdown', (e) => {
                if (!lockActive) return;
                lockDragging = true;
                lockDragStartY = e.clientY;
                lockDragDelta = 0;
                lockscreen.classList.add('dragging');
                lockscreen.setPointerCapture(e.pointerId);
            });
            lockscreen.addEventListener('pointermove', (e) => {
                if (!lockActive || !lockDragging) return;
                const delta = Math.max(0, e.clientY - lockDragStartY);
                lockDragDelta = delta;
                lockscreen.style.transform = `translateY(${delta}px)`;
            });
            lockscreen.addEventListener('pointerup', () => {
                if (!lockActive || !lockDragging) return;
                lockDragging = false;
                if (lockDragDelta > 90) {
                    unlockLockscreen();
                } else {
                    resetLockscreenPosition();
                }
            });
            lockscreen.addEventListener('pointercancel', () => {
                if (!lockActive) return;
                lockDragging = false;
                resetLockscreenPosition();
            });
        }

        // HELPERS
        function updateDisplay() {
            if (lockActive && keypad) {
                keypad.classList.add('locked');
            }
            if (buffer) {
                if (suggestionActive && activeSuggestionDisplay && pendingPrompt === 'log message') {
                    const b = buffer;
                    const s = activeSuggestionDisplay;
                    const sLower = s.toLowerCase();
                    const bLower = b.toLowerCase();
                    if (sLower.startsWith(bLower) && s.length >= b.length) {
                        const tail = s.slice(b.length);
                        const animated = b.split('').map((ch, idx) => {
                            const delay = `${(idx % 6) * 0.12}s`;
                            return `<span class="float-char" style="--float-delay:${delay}">${ch}</span>`;
                        }).join('');
                        displayNumber.innerHTML = `${animated}<span class="ghost">${tail}</span>`;
                    } else {
                        const animated = buffer.split('').map((ch, idx) => {
                            const delay = `${(idx % 6) * 0.12}s`;
                            return `<span class="float-char" style="--float-delay:${delay}">${ch}</span>`;
                        }).join('');
                        displayNumber.innerHTML = animated;
                    }
                } else {
                    const animated = buffer.split('').map((ch, idx) => {
                        const delay = `${(idx % 6) * 0.12}s`;
                        return `<span class="float-char" style="--float-delay:${delay}">${ch}</span>`;
                    }).join('');
                    displayNumber.innerHTML = animated;
                }
                displayNumber.classList.add('visible');
            } else {
                displayNumber.textContent = '';
                displayNumber.classList.remove('visible');
            }

            if (topbar) {
                if (buffer && buffer.length > 0) {
                    topbar.classList.add('hidden');
                } else {
                    topbar.classList.remove('hidden');
                }
            }

            if (uiMode !== 'nav') {
                if (lastServerRender) {
                    screenUI.setLastRender(lastServerRender);
                }
            }

            if (pendingType && pendingPrompt) {
                displayLabel.textContent = `Input: ${pendingPrompt}`;
            } else if (!buffer) {
                displayLabel.textContent = 'Ready.';
            }
        }

        function resetMultiTap() {
            lastTapKey = null;
            lastTapIndex = 0;
            lastTapTime = 0;
        }

        class Menu {
            constructor(title, items, onSelect) {
                this.title = title;
                this.items = items;
                this.onSelect = onSelect;
            }
        }

        function setMode(mode) {
            uiMode = 'classic';
            keypad.classList.remove('mode-classic', 'mode-nav');
            keypad.classList.add('mode-classic');
            updateNavKeys();
            renderMenu();
        }

        function updateNavKeys() {
            const navKeys = new Set(['2', '4', '6', '8', '5']);
            keys.forEach(k => {
                const num = k.dataset.num;
                if (!num) return;
                if (uiMode === 'nav' && navKeys.has(num)) {
                    k.classList.add('nav-active');
                } else {
                    k.classList.remove('nav-active');
                }
            });
        }

        function renderMenu() {
            if (uiMode !== 'nav') {
                displayMessages.classList.remove('menu');
                displayMessages.style.overflowY = 'auto';
                screenUI.renderLast();
                return;
            }
            displayMessages.classList.remove('menu');
            displayMessages.style.overflowY = 'auto';
            screenUI.renderLast();
        }

        function renderFountain() {
            displayMessages.classList.remove('menu');
            displayMessages.style.overflowY = 'hidden';
            const num = String(Math.max(0, Math.floor(fountainValue))).padStart(8, '0');
            displayMessages.innerHTML = `
                <div class="fountain-wrap">
                    <div class="fountain-count">${num}</div>
                </div>
            `;
            if (fountainValue > lastFountainValue) {
                const countEl = displayMessages.querySelector('.fountain-count');
                if (countEl) {
                    countEl.classList.remove('pop');
                    void countEl.offsetWidth;
                    countEl.classList.add('pop');
                }
            }
            lastFountainValue = fountainValue;
        }

        function setSubScreen(name) {
            subScreen = name;
            renderMenu();
        }

        function updateFountainValue(delta) {
            const maxVal = Math.max(0, Math.floor(currentScore));
            fountainValue = Math.max(0, Math.min(maxVal, fountainValue + delta));
            renderFountain();
        }

        function startHold(dir) {
            if (holdTimer || holdDelayTimer) return;
            holdDir = dir;
            holdDelayTimer = setTimeout(() => {
                holdActive = true;
                holdUsed = true;
                holdStart = Date.now();
                holdTimer = setInterval(() => {
                    const elapsed = Date.now() - holdStart;
                    const accel = Math.min(40, 1 + Math.floor(elapsed / 150));
                    updateFountainValue(holdDir * accel);
                }, 70);
                holdDelayTimer = null;
            }, 200);
        }

        function stopHold() {
            if (holdDelayTimer) {
                clearTimeout(holdDelayTimer);
                holdDelayTimer = null;
            }
            if (holdTimer) {
                clearInterval(holdTimer);
                holdTimer = null;
            }
            holdActive = false;
            holdDir = 0;
        }

        function currentMenu() {
            return menuStack.length > 0 ? menuStack[menuStack.length - 1] : null;
        }

        function setRootMenu() {
            menuStack = [rootMenu()];
            menuSelection = 0;
        }

        function rootMenu() {
            return new Menu(
                'MENU',
                [
                    { key: 'settings', label: 'Configurations' },
                    { key: 'packages', label: 'Packages' }
                ],
                async (item) => {
                    if (item.key === 'settings') {
                        await loadSettingsMenu();
                        menuStack.push(settingsMenu());
                        menuSelection = 0;
                        renderMenu();
                    } else if (item.key === 'packages') {
                        await loadPackagesMenu();
                        menuStack.push(packagesMenu());
                        menuSelection = 0;
                        renderMenu();
                    }
                }
            );
        }

        function settingsMenu() {
            const agentLabel = settingsData
                ? `Virtual Agent: ${settingsData.virtual_agent_active ? '[ENABLED]' : '[DISABLED]'}`
                : 'Virtual Agent: [LOADING]';
            const modeLabel = settingsData
                ? `Current Mode: ${String(settingsData.mode || '').toUpperCase()}`
                : 'Current Mode: [LOADING]';
            return new Menu(
                'SETTINGS',
                [
                    { key: 'agent', label: agentLabel },
                    { key: 'mode', label: modeLabel },
                    { key: 'back', label: 'Back' }
                ],
                async (item) => {
                    if (item.key === 'agent') {
                        await toggleAgent();
                        menuStack[menuStack.length - 1] = settingsMenu();
                    } else if (item.key === 'mode') {
                        await cycleMode();
                        menuStack[menuStack.length - 1] = settingsMenu();
                    } else if (item.key === 'back') {
                        popMenu();
                        return;
                    }
                    renderMenu();
                }
            );
        }

        function packagesMenu() {
            const items = [];
            if (packagesData) {
                packagesData.forEach(p => {
                    const owned = p.owned ? ' [OWNED]' : '';
                    items.push({ key: p.key, label: `${p.name}${owned}` });
                });
            } else {
                items.push({ key: 'loading', label: 'Loading...' });
            }
            items.push({ key: 'back', label: 'Back' });
            return new Menu(
                'PACKAGES',
                items,
                async (item) => {
                    if (item.key === 'back') {
                        popMenu();
                        return;
                    }
                    if (item.key === 'loading') return;
                    await importPackage(item.key);
                    await loadPackagesMenu();
                    menuStack[menuStack.length - 1] = packagesMenu();
                    renderMenu();
                }
            );
        }

        function popMenu() {
            if (menuStack.length > 1) {
                menuStack.pop();
                menuSelection = 0;
                renderMenu();
            } else {
                setMode('classic');
            }
        }

        async function loadSettingsMenu() {
            try {
                const res = await fetch('/api/menu/settings');
                if (!res.ok) return;
                settingsData = await res.json();
            } catch (e) { /* ignore */ }
        }

        async function toggleAgent() {
            try {
                const res = await fetch('/api/menu/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'toggle_agent' })
                });
                if (!res.ok) return;
                settingsData = await res.json();
            } catch (e) { /* ignore */ }
        }

        async function cycleMode() {
            try {
                const res = await fetch('/api/menu/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'cycle_mode' })
                });
                if (!res.ok) return;
                settingsData = await res.json();
            } catch (e) { /* ignore */ }
        }

        async function loadPackagesMenu() {
            try {
                const res = await fetch('/api/menu/packages');
                if (!res.ok) return;
                const data = await res.json();
                packagesData = Array.isArray(data.packages) ? data.packages : [];
            } catch (e) { /* ignore */ }
        }

        async function importPackage(key) {
            try {
                const res = await fetch('/api/menu/packages/import', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ key })
                });
                if (!res.ok) return;
                const data = await res.json();
                if (data && data.ok) {
                    showToast('Imported');
                }
            } catch (e) { /* ignore */ }
        }

        async function offerFountain() {
            const amount = Math.max(0, Math.floor(fountainValue));
            if (amount <= 0) return;
            const maxVal = Math.max(0, Math.floor(currentScore));
            const offerVal = Math.min(amount, maxVal);
            if (offerVal <= 0) return;
            try {
                const res = await fetch('/api/fountain/offer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ value: offerVal })
                });
                if (!res.ok) return;
                const data = await res.json();
                const total = typeof data.total === 'number' ? data.total : offerVal;
                const remaining = typeof data.remaining === 'number' ? data.remaining : Math.max(0, maxVal - offerVal);
                const countEl = displayMessages.querySelector('.fountain-count');
                if (countEl) {
                    countEl.classList.remove('throw');
                    void countEl.offsetWidth;
                    countEl.classList.add('throw');
                }
                setTimeout(() => {
                    fountainValue = total;
                    renderFountain();
                    setTimeout(() => {
                        fountainValue = remaining;
                        renderFountain();
                    }, 700);
                }, 650);
            } catch (e) { /* ignore */ }
        }

        async function fetchLogSuggestions() {
            try {
                const res = await fetch('/api/log_suggestions');
                if (!res.ok) return;
                const data = await res.json();
                if (Array.isArray(data.suggestions)) {
                    logSuggestions = data.suggestions;
                }
                if (typeof data.base === 'string') {
                    baseSuggestion = data.base;
                }
            } catch (e) { /* ignore */ }
        }

        function updateLogSuggestion() {
            if (pendingType !== 'text' || pendingPrompt !== 'log message') {
                activeSuggestion = '';
                activeSuggestionDisplay = '';
                suggestionActive = false;
                return;
            }
            const needle = buffer.trim().toLowerCase();
            let suggestion = '';
            let suggestionDisplay = '';
            if (!needle && baseSuggestion) {
                const baseLower = String(baseSuggestion).toLowerCase();
                suggestion = baseLower;
                suggestionDisplay = baseLower;
            }
            for (const s of logSuggestions) {
                const sLower = String(s).toLowerCase();
                if (!needle || sLower.startsWith(needle)) {
                    if (sLower !== needle) {
                        suggestion = sLower;
                        suggestionDisplay = sLower;
                        break;
                    }
                }
            }
            activeSuggestion = suggestion;
            activeSuggestionDisplay = suggestionDisplay;
            suggestionActive = !!suggestion;
            if (suggestionActive) {
                displayLabel.textContent = `Suggest: ${activeSuggestionDisplay}`;
            }
        }

        function toTitleCase(str) {
            return String(str || '')
                .trim()
                .split(/\s+/)
                .filter(Boolean)
                .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
                .join(' ');
        }

        function showToast(msg) {
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        async function fetchPreview(buf) {
            if (pendingType) {
                if (pendingPrompt) {
                    displayLabel.textContent = `Input: ${pendingPrompt}`;
                }
                return;
            }
            if (!buf) {
                displayLabel.textContent = 'Ready.';
                return;
            }

            try {
                const res = await fetch(`/api/preview?buffer=${encodeURIComponent(buf)}`);
                if (!res.ok) throw new Error('offline');
                const data = await res.json();
                
                let preview = data.preview
                    .replace(/ -> /g, ' › ')
                    .replace(/_/g, '')
                    .trim();
                
                displayLabel.textContent = preview || 'Processing...';

                if (data.complete && !data.ambiguous && !executing && buf === buffer && !pendingType) {
                    executing = true;
                    executeCommand(buf).finally(() => {
                        executing = false;
                    });
                }
            } catch (e) {
                displayLabel.textContent = buf;
            }
        }

        async function updateStatus() {
            if (statusInFlight) return;
            statusInFlight = true;
            if (statusTimeoutTimer) clearTimeout(statusTimeoutTimer);
            statusTimeoutTimer = setTimeout(() => {
                showLoadscreen();
                statusInFlight = false;
            }, STATUS_TIMEOUT_MS);
            try {
                const res = await fetch('/api/status');
                if (!res.ok) {
                    if (statusTimeoutTimer) clearTimeout(statusTimeoutTimer);
                    showLoadscreen();
                    setConnectionStatus('OFFLINE');
                    statusInFlight = false;
                    return;
                }
                const data = await res.json();
                if (statusTimeoutTimer) clearTimeout(statusTimeoutTimer);
                setLoadProgress(100);
                setLoadMessage('Online');
                setConnectionStatus('ONLINE');
                hideLoadscreen();
                statusInFlight = false;

                if (data.user) {
                    const metaScore = data.user.metadata && typeof data.user.metadata.score === 'number'
                        ? data.user.metadata.score
                        : null;
                    const scoreVal = (metaScore !== null)
                        ? metaScore
                        : (typeof data.user.score === 'number' ? data.user.score : null);
                    if (scoreVal !== null) {
                        displayPoints.textContent = Math.round(scoreVal).toString();
                        currentScore = Math.round(scoreVal);
                        if (fountainValue > currentScore) {
                            fountainValue = currentScore;
                            if (uiMode === 'nav' && subScreen === 'fountain') {
                                renderFountain();
                            }
                        }
                    }
                }

                if (data.pending) {
                    pendingPrompt = data.pending.prompt || 'required';
                    pendingType = data.pending.type || '';
                    if (data.pending.type === 'text') {
                        inputMode = 'text';
                        displayLabel.textContent = `Input: ${pendingPrompt}`;
                        keypad.classList.add('text-input-active');
                        if (pendingPrompt === 'log message' && logSuggestions.length === 0) {
                            fetchLogSuggestions().then(updateLogSuggestion);
                        }
                    } else {
                        inputMode = 'dial';
                        keypad.classList.remove('text-input-active');
                    }
                    // cancel button removed; handled via long-press delete
                    if (data.pending.type !== 'text') {
                        resetMultiTap();
                    }
                    updateLogSuggestion();
                    updateDisplay();
                } else {
                    pendingPrompt = '';
                    pendingType = '';
                    if (inputMode !== 'dial') {
                        inputMode = 'dial';
                    }
                    keypad.classList.remove('text-input-active');
                    resetMultiTap();
                    updateLogSuggestion();
                    updateDisplay();
                }

                if (data.messages && data.messages.length > 0) {
                    if (uiMode !== 'nav') {
                        screenUI.showFromMessages(data.messages);
                        lastServerRender = screenUI.getLastRender();
                        showToast(data.messages[data.messages.length - 1]);
                        const createHit = data.messages.some((msg) => {
                            const text = String(msg || '').toLowerCase();
                            return text.includes(' created ') || text.includes(" created with id") || text.startsWith("action '") && text.includes(' created');
                        });
                        if (createHit) {
                            playCreateJingle();
                        }
                    }
                }
            } catch (e) {
                if (statusTimeoutTimer) clearTimeout(statusTimeoutTimer);
                setLoadMessage('Connecting...');
                showLoadscreen();
                setConnectionStatus('OFFLINE');
                statusInFlight = false;
            }
        }

        async function updateBootStatus() {
            try {
                const res = await fetch('/api/boot');
                if (!res.ok) throw new Error('boot');
                const data = await res.json();
                if (typeof data.progress === 'number') {
                    setLoadProgress(Math.max(30, data.progress));
                }
                if (data.message) {
                    setLoadMessage(data.message);
                }
                if (data.ready && bootTimer) {
                    clearInterval(bootTimer);
                    bootTimer = null;
                }
            } catch (e) {
                setLoadMessage('Backend offline');
            }
        }

        async function executeCommand(buf) {
            try {
                const res = await fetch('/api/command', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ buffer: buf })
                });
                
                const data = await res.json();
                
                if (data.completed) {
                    showToast('Command executed');
                    buffer = '';
                    pendingPrompt = '';
                    pendingType = '';
                    keypad.classList.remove('text-input-active');
                    resetMultiTap();
                    updateLogSuggestion();
                    updateDisplay();
                    displayLabel.textContent = 'Ready.';
                    updateStatus();
                }
            } catch (e) {
                showToast('Offline');
            }
        }

        // DTMF TONES
        let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const dtmfFreqs = {
            '1': [697, 1209], '2': [697, 1336], '3': [697, 1477],
            '4': [770, 1209], '5': [770, 1336], '6': [770, 1477],
            '7': [852, 1209], '8': [852, 1336], '9': [852, 1477],
            '0': [941, 1336], '*': [941, 1209], '#': [941, 1477]
        };
        const dtmfPitch = 0.8;

        function playTone(freq, duration = 80, type = 'triangle', volume = 0.12) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.value = volume;
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(volume, now + 0.005);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + duration / 1000);
            osc.start(now);
            osc.stop(now + duration / 1000 + 0.02);
        }

        function playUnlockJingle() {
            playTone(900, 60, 'triangle', 0.1);
            setTimeout(() => playTone(1200, 60, 'triangle', 0.1), 70);
            setTimeout(() => playTone(1500, 70, 'triangle', 0.11), 140);
        }

        function playListJingle() {
            playTone(700, 60, 'triangle', 0.08);
            setTimeout(() => playTone(980, 60, 'triangle', 0.08), 60);
        }

        function playActionJingle() {
            playTone(520, 50, 'sine', 0.08);
            setTimeout(() => playTone(780, 60, 'triangle', 0.1), 50);
            setTimeout(() => playTone(1040, 70, 'triangle', 0.11), 120);
        }

        function playCreateJingle() {
            playTone(880, 50, 'triangle', 0.09);
            setTimeout(() => playTone(1320, 70, 'triangle', 0.11), 60);
            setTimeout(() => playTone(1760, 80, 'triangle', 0.12), 130);
        }

        function playStatsJingle() {
            playTone(600, 60, 'sine', 0.08);
            setTimeout(() => playTone(900, 60, 'triangle', 0.1), 70);
            setTimeout(() => playTone(1200, 60, 'triangle', 0.1), 140);
        }
        
        function playDTMF(digit, duration = 100) {
            if (!dtmfFreqs[digit]) return;
            
            const [freq1, freq2] = dtmfFreqs[digit];
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const delay = audioCtx.createDelay(1.0);
            const feedback = audioCtx.createGain();
            const wet = audioCtx.createGain();
            const dry = audioCtx.createGain();
            
            osc1.frequency.value = freq1 * dtmfPitch;
            osc2.frequency.value = freq2 * dtmfPitch;
            osc1.type = 'sine';
            osc2.type = 'sine';
            gain.gain.value = 0.1;
            delay.delayTime.value = 0.12;
            feedback.gain.value = 0.35;
            wet.gain.value = 0.35;
            dry.gain.value = 0.8;
            
            osc1.connect(gain);
            osc2.connect(gain);
            gain.connect(dry);
            gain.connect(delay);
            delay.connect(feedback);
            feedback.connect(delay);
            delay.connect(wet);
            dry.connect(audioCtx.destination);
            wet.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.1, now + 0.01);
            gain.gain.linearRampToValueAtTime(0, now + duration / 1000);
            
            osc1.start(now);
            osc2.start(now);
            osc1.stop(now + duration / 1000);
            osc2.stop(now + duration / 1000);
        }

        // KEY PRESS
        keys.forEach(key => {
            key.addEventListener('click', () => {
                const num = key.dataset.num;
                const char = key.dataset.char;
                const confirm = key.dataset.confirm;
                const del = key.dataset.delete;
                if (num) {
                    if (lockActive) {
                        unlockLockscreen();
                        return;
                    }
                    if (uiMode === 'nav' && !pendingType) {
                        const menu = currentMenu();
                        if (!menu || menu.items.length === 0) return;
                        if (num === '2') {
                            menuSelection = (menuSelection - 1 + menu.items.length) % menu.items.length;
                            renderMenu();
                        } else if (num === '8') {
                            if (subScreen === 'fountain') {
                                if (holdUsed) {
                                    holdUsed = false;
                                }
                            } else {
                                menuSelection = (menuSelection + 1) % menu.items.length;
                                renderMenu();
                            }
                        } else if (num === '1') {
                            setSubScreen('list');
                        } else if (num === '3') {
                            setSubScreen('fountain');
                        } else if (num === '4') {
                            popMenu();
                        } else if (num === '6' || num === '5') {
                            if (subScreen === 'fountain' && num === '5') {
                                offerFountain();
                            } else {
                                const item = menu.items[menuSelection];
                                if (menu.onSelect) {
                                    menu.onSelect(item);
                                }
                            }
                        } else if (num === '9') {
                            popMenu();
                        }
                        key.classList.add('pressed');
                        setTimeout(() => key.classList.remove('pressed'), 200);
                        return;
                    }
                    if (pendingType === 'menu') {
                        playDTMF(num);
                        if (navigator.vibrate) navigator.vibrate(10);
                        key.classList.add('pressed');
                        setTimeout(() => key.classList.remove('pressed'), 300);
                        executeCommand(num);
                        return;
                    }
                    if (pendingType === 'text') {
                        if (num === '0') {
                            if (buffer && !buffer.endsWith(' ')) {
                                buffer += ' ';
                                resetMultiTap();
                                updateDisplay();
                            } else if (!buffer) {
                                buffer = ' ';
                                resetMultiTap();
                                updateDisplay();
                            }
                        }
                        const letters = textMap[num];
                        if (letters) {
                            const now = Date.now();
                            if (lastTapKey === num && (now - lastTapTime) < multiTapTimeout && buffer.length > 0) {
                                lastTapIndex = (lastTapIndex + 1) % letters.length;
                                buffer = buffer.slice(0, -1) + letters[lastTapIndex];
                            } else {
                                lastTapKey = num;
                                lastTapIndex = 0;
                                buffer += letters[0];
                            }
                            lastTapTime = now;
                            updateDisplay();
                            updateLogSuggestion();
                        }
                    } else {
                        playDTMF(num);
                        buffer += num;
                        updateDisplay();
                        fetchPreview(buffer);
                    }
                    
                    if (navigator.vibrate) navigator.vibrate(10);
                    
                    key.classList.add('pressed');
                    setTimeout(() => key.classList.remove('pressed'), 300);
                } else if (char) {
                    if (lockActive) {
                        unlockLockscreen();
                        return;
                    }
                    buffer += char;
                    updateDisplay();
                    fetchPreview(buffer);

                    if (navigator.vibrate) navigator.vibrate(10);

                    key.classList.add('pressed');
                    setTimeout(() => key.classList.remove('pressed'), 300);
                } else if (del) {
                    if (lockActive) {
                        unlockLockscreen();
                        return;
                    }
                    playTone(2800, 60, 'sine', 0.1);
                    if (screenUI.exitListOrSequence()) {
                        lastServerRender = null;
                        return;
                    }
                    if (buffer.length === 0) return;
                    buffer = buffer.slice(0, -1);
                    if (pendingType === 'text' && buffer.length === 0) {
                        resetMultiTap();
                    }
                    updateDisplay();
                    updateLogSuggestion();
                    fetchPreview(buffer);
                } else if (confirm) {
                    if (lockActive) {
                        unlockLockscreen();
                        return;
                    }
                    playTone(1800, 70, 'triangle', 0.12);
                    if (!pendingType && buffer.length === 0) {
                        if (screenUI.nextListPage()) {
                            return;
                        }
                        return;
                    }
                    if (suggestionActive && activeSuggestion) {
                        buffer = activeSuggestion;
                        suggestionActive = false;
                        activeSuggestion = '';
                        activeSuggestionDisplay = '';
                        updateDisplay();
                        updateLogSuggestion();
                        return;
                    }
                    if (!buffer) {
                        showToast('Enter text');
                        return;
                    }
                    if (pendingType === 'text') {
                        executeCommand(toTitleCase(buffer));
                    } else {
                        executeCommand(buffer);
                    }
                }
            });
        });

        // Long press on 0 = delete last char
        let longPressTimer;
        const zeroKey = document.querySelector('[data-num="0"]');
        
        zeroKey.addEventListener('touchstart', (e) => {
            longPressTimer = setTimeout(() => {
                if (buffer.length > 0) {
                    buffer = buffer.slice(0, -1);
                    updateDisplay();
                    fetchPreview(buffer);
                    if (navigator.vibrate) navigator.vibrate([15, 5, 15]);
                }
            }, 500);
        });
        
        zeroKey.addEventListener('touchend', () => {
            clearTimeout(longPressTimer);
        });
        
        // Long press delete key = cancel pending (if any), else clear all
        let deleteAllTimer;
        const deleteKey = document.querySelector('[data-delete="1"]');
        if (deleteKey) {
            deleteKey.addEventListener('touchstart', () => {
                deleteAllTimer = setTimeout(() => {
                    if (pendingType) {
                        cancelPending();
                        if (navigator.vibrate) navigator.vibrate([15, 5, 15]);
                        return;
                    }
                    if (buffer.length === 0) return;
                    buffer = '';
                    resetMultiTap();
                    updateDisplay();
                    fetchPreview(buffer);
                    if (navigator.vibrate) navigator.vibrate([15, 5, 15]);
                }, 550);
            });
            deleteKey.addEventListener('touchend', () => {
                clearTimeout(deleteAllTimer);
            });
        }

        const twoKey = document.querySelector('[data-num="2"]');
        const eightKey = document.querySelector('[data-num="8"]');
        if (twoKey) {
            twoKey.addEventListener('touchstart', () => {
                if (uiMode === 'nav' && subScreen === 'fountain' && !pendingType) {
                    startHold(1);
                }
            });
            twoKey.addEventListener('touchend', () => stopHold());
            twoKey.addEventListener('mousedown', () => {
                if (uiMode === 'nav' && subScreen === 'fountain' && !pendingType) {
                    startHold(1);
                }
            });
            twoKey.addEventListener('mouseup', () => stopHold());
            twoKey.addEventListener('mouseleave', () => stopHold());
        }
        if (eightKey) {
            eightKey.addEventListener('touchstart', () => {
                if (uiMode === 'nav' && subScreen === 'fountain' && !pendingType) {
                    startHold(-1);
                }
            });
            eightKey.addEventListener('touchend', () => stopHold());
            eightKey.addEventListener('mousedown', () => {
                if (uiMode === 'nav' && subScreen === 'fountain' && !pendingType) {
                    startHold(-1);
                }
            });
            eightKey.addEventListener('mouseup', () => stopHold());
            eightKey.addEventListener('mouseleave', () => stopHold());
        }

        // INIT
        async function init() {
            updateLockTime();
            setInterval(updateLockTime, 1000);
            bindLockscreenGestures();
            inputMode = 'dial';
            pendingPrompt = '';
            pendingType = '';
            resetMultiTap();
            updateLogSuggestion();
            setMode('classic');
            updateDisplay();
            showLoadscreen();
            setConnectionStatus('CONNECTING');
            setLoadProgress(10);
            setLoadMessage('DOM ready');
            updateBootStatus();
            bootTimer = setInterval(updateBootStatus, 1000);
            updateStatus();
            setInterval(updateStatus, 3000);
        }

        init();

        window.addEventListener('load', () => {
            if (loadProgress < 30) {
                setLoadProgress(30);
                setLoadMessage('Assets loaded');
            }
        });

        window.addEventListener('online', () => {
            setConnectionStatus('ONLINE');
            updateStatus();
        });

        window.addEventListener('offline', () => {
            setConnectionStatus('OFFLINE');
        });

        async function cancelPending() {
            try {
                await fetch('/api/cancel', { method: 'POST' });
            } catch (e) { /* ignore */ }
            buffer = '';
            pendingPrompt = '';
            pendingType = '';
            resetMultiTap();
            updateDisplay();
            displayLabel.textContent = 'Ready.';
            updateStatus();
        }
    </script>
</body>
</html>
